{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gameta Gameta is a powerful CLI tool that helps you to manage meta-repositories or metarepos . It allows you to creates links to related repositories, make changes and sync them, and provides functionality to customise and apply other CLI commands to these repositories. Gameta is a play on the word gamete (reproductive cells), and similar to how gametes form the building blocks for life, gameta helps to manage the many repositories that form the building blocks for more complex software. System Requirements Gameta requries Python 3.7+, it is designed to be multi-platform but currently only tested in Linux environments. Installation Gameta can be easily installed and updated via pip: $ pip install gameta # install $ pip install -U gameta # update Getting Started Getting started is really easy. gameta init gameta init -g # To initialise directory as a Git repo Gameta will extract git information and create the .meta file which stores all your project configurations. { projects : { gameta : { path : . , tags : [ metarepo ], url : https://github.com:genius-systems/gameta.git } } } Note If your project has not been initialised with Git, you can specify the --git or -g flag to perform a git init, but you will have to update the repository URL manually later on. If your repository contains a .meta file generated by Gameta, simply run the following command to sync all linked repositories locally: gameta sync Adding a Repository Run the following command to add a new repository. gameta repo add -n GitPython -u https://github.com/gitpython-developers/GitPython.git -p GitPython Note The path variable is the relative path within the metarepo itself You should see another entry under the projects object within the .meta file { projects : { gameta : { path : . , tags : [ metarepo ], url : git@github.com:genius-systems/gameta.git }, GitPython : { path : GitPython , tags : [ a , b , c ], url : https://github.com/gitpython-developers/GitPython.git } } } You should also see the repository cloned to the relative path specified Applying commands Gameta provides a powerful toolkit to manage your set of repositories. gameta apply -c git fetch --all --tags --prune -c git merge The command above applies the following to all repositories: Fetches all git updates, tags and prunes redundant git artifacts Merges changes on the default branch There's alot more that you can do with commands, see the Applying Commands page for more information Best practices Learn how to leverage on Gameta's capabilities in the Best Practices page","title":"Home"},{"location":"#gameta","text":"Gameta is a powerful CLI tool that helps you to manage meta-repositories or metarepos . It allows you to creates links to related repositories, make changes and sync them, and provides functionality to customise and apply other CLI commands to these repositories. Gameta is a play on the word gamete (reproductive cells), and similar to how gametes form the building blocks for life, gameta helps to manage the many repositories that form the building blocks for more complex software.","title":"Gameta"},{"location":"#system-requirements","text":"Gameta requries Python 3.7+, it is designed to be multi-platform but currently only tested in Linux environments.","title":"System Requirements"},{"location":"#installation","text":"Gameta can be easily installed and updated via pip: $ pip install gameta # install $ pip install -U gameta # update","title":"Installation"},{"location":"#getting-started","text":"Getting started is really easy. gameta init gameta init -g # To initialise directory as a Git repo Gameta will extract git information and create the .meta file which stores all your project configurations. { projects : { gameta : { path : . , tags : [ metarepo ], url : https://github.com:genius-systems/gameta.git } } } Note If your project has not been initialised with Git, you can specify the --git or -g flag to perform a git init, but you will have to update the repository URL manually later on. If your repository contains a .meta file generated by Gameta, simply run the following command to sync all linked repositories locally: gameta sync","title":"Getting Started"},{"location":"#adding-a-repository","text":"Run the following command to add a new repository. gameta repo add -n GitPython -u https://github.com/gitpython-developers/GitPython.git -p GitPython Note The path variable is the relative path within the metarepo itself You should see another entry under the projects object within the .meta file { projects : { gameta : { path : . , tags : [ metarepo ], url : git@github.com:genius-systems/gameta.git }, GitPython : { path : GitPython , tags : [ a , b , c ], url : https://github.com/gitpython-developers/GitPython.git } } } You should also see the repository cloned to the relative path specified","title":"Adding a Repository"},{"location":"#applying-commands","text":"Gameta provides a powerful toolkit to manage your set of repositories. gameta apply -c git fetch --all --tags --prune -c git merge The command above applies the following to all repositories: Fetches all git updates, tags and prunes redundant git artifacts Merges changes on the default branch There's alot more that you can do with commands, see the Applying Commands page for more information","title":"Applying commands"},{"location":"#best-practices","text":"Learn how to leverage on Gameta's capabilities in the Best Practices page","title":"Best practices"},{"location":"about/contributing/","text":"Contributing to Gameta Gameta welcomes, and depends, on contributions from developers and users in the open source community. Contributions can be made in a number of ways, a few examples are: Code patches via pull requests Documentation improvements Bug reports and patch reviews Code of Conduct Everyone interacting in the Gameta's codebases, issue trackers, chat rooms, and mailing lists is expected to follow the PyPA Code of Conduct . Reporting an Issue Please include as much detail as you can. Let us know your platform and Gameta version. If you get an error please include the full error and traceback. Testing the Development Version If you want to just install and try out the latest development version of Gameta you can do so with the following command. This can be useful if you want to provide feedback for a new feature or want to confirm if a bug you have encountered is fixed in the git master. It is strongly recommended that you do this within a virtualenv . pip install git+https://github.com/genius-systems/gameta.git@master Installing for Development First you'll need to fork and clone the repository. Once you have a local copy, run the following command. It is strongly recommended that you do this within a virtualenv . pip install --editable . This will install Gameta in development mode which binds the gameta command to the git repository. Running the tests To run the tests, it is recommended that you use tox . Install Tox using pip by running the command pip install tox . Then the test suite can be run with the command tox in the root of your Gameta repository. It will attempt to run the tests against all of the Python versions we support. So don't be concerned if you are missing some and they fail. The rest will be verified when you submit a pull request. Submitting Pull Requests Once you are happy with your changes or you are ready for some feedback, push it to your fork and send a pull request. For a change to be accepted it will most likely need to have tests and documentation if it is a new feature.","title":"Contributing"},{"location":"about/contributing/#contributing-to-gameta","text":"Gameta welcomes, and depends, on contributions from developers and users in the open source community. Contributions can be made in a number of ways, a few examples are: Code patches via pull requests Documentation improvements Bug reports and patch reviews","title":"Contributing to Gameta"},{"location":"about/contributing/#code-of-conduct","text":"Everyone interacting in the Gameta's codebases, issue trackers, chat rooms, and mailing lists is expected to follow the PyPA Code of Conduct .","title":"Code of Conduct"},{"location":"about/contributing/#reporting-an-issue","text":"Please include as much detail as you can. Let us know your platform and Gameta version. If you get an error please include the full error and traceback.","title":"Reporting an Issue"},{"location":"about/contributing/#testing-the-development-version","text":"If you want to just install and try out the latest development version of Gameta you can do so with the following command. This can be useful if you want to provide feedback for a new feature or want to confirm if a bug you have encountered is fixed in the git master. It is strongly recommended that you do this within a virtualenv . pip install git+https://github.com/genius-systems/gameta.git@master","title":"Testing the Development Version"},{"location":"about/contributing/#installing-for-development","text":"First you'll need to fork and clone the repository. Once you have a local copy, run the following command. It is strongly recommended that you do this within a virtualenv . pip install --editable . This will install Gameta in development mode which binds the gameta command to the git repository.","title":"Installing for Development"},{"location":"about/contributing/#running-the-tests","text":"To run the tests, it is recommended that you use tox . Install Tox using pip by running the command pip install tox . Then the test suite can be run with the command tox in the root of your Gameta repository. It will attempt to run the tests against all of the Python versions we support. So don't be concerned if you are missing some and they fail. The rest will be verified when you submit a pull request.","title":"Running the tests"},{"location":"about/contributing/#submitting-pull-requests","text":"Once you are happy with your changes or you are ready for some feedback, push it to your fork and send a pull request. For a change to be accepted it will most likely need to have tests and documentation if it is a new feature.","title":"Submitting Pull Requests"},{"location":"about/license/","text":"License (MIT) Copyright (c) 2020 David Lee Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"about/license/#license-mit","text":"Copyright (c) 2020 David Lee Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License (MIT)"},{"location":"about/release_notes/","text":"Release Notes Upgrading To upgrade Gameta to the latest version, use pip: pip install -U gameta You can determine your currently installed version using gameta --version : gameta --version Maintenance team The current members of the Gameta team. @darkvariantdivine Version 0.1.0 (2020-10-30) Added init command to initialise an empty repository Added the sync command to sync changes locally Added the repo CLI commands to add, delete, update and list repositories Added the tags CLI commands to add and delete repository tags Added the params CLI commands to add and delete repository parameters Added the cmd CLI commands to add, delete, update, list and execute Gameta commands","title":"Release Notes"},{"location":"about/release_notes/#release-notes","text":"","title":"Release Notes"},{"location":"about/release_notes/#upgrading","text":"To upgrade Gameta to the latest version, use pip: pip install -U gameta You can determine your currently installed version using gameta --version : gameta --version","title":"Upgrading"},{"location":"about/release_notes/#maintenance-team","text":"The current members of the Gameta team. @darkvariantdivine","title":"Maintenance team"},{"location":"about/release_notes/#version-010-2020-10-30","text":"Added init command to initialise an empty repository Added the sync command to sync changes locally Added the repo CLI commands to add, delete, update and list repositories Added the tags CLI commands to add and delete repository tags Added the params CLI commands to add and delete repository parameters Added the cmd CLI commands to add, delete, update, list and execute Gameta commands","title":"Version 0.1.0 (2020-10-30)"},{"location":"metarepos/metarepos/","text":"What is a Metarepo? A metarepo is a repository that contains links to other related repositories and usually serves as consolidating repository for a particular system, project or organisation i.e. system-level dependencies, build, deployment and release scripts are stored here. A nice article discussing metarepos can be found here Monorepos A dichotomy exists in the way we store and manage code at present, at one end of the spectrum we have the monorepo, a single repository containing all source code within a project or organisation. The monorepo has various advantages, for instance project discovery, dependencies and versioning are much simpler to manage. However, this comes at the expense of complicated, customised tooling, increasing complexity when scaling and upgrading the system and long CI/CD build times. Proponents of this methodology include companies like Google, Facebook and Twitter, many of whom can afford huge teams to customise tools to manage such an ecosystem. Multirepos At the other end of the spectrum, we have the multirepo architecture, where source code is split across many repositories. In this paradigm, the advantages and disadvantages of the monorepo are reversed i.e. the project is dissociated into smaller organised parts and these parts becomes easier to manage, whereas coordinating all of these fragmented pieces of software becomes a nightmare. Metarepos Metarepos provide a middle ground between these 2 polar extremes. Source code is stored across many repositories, allowing the organisation to capitalise on the benefits of a multirepo architecture. The fragmented code landscape is pieced together in a single repository or metarepo that stores links to the relevant code bases rather than the actual code itself. Actual code is pulled from the child repositories whenever required e.g. during build and delivery, enabling users to capitalise on the benefits of a monorepo architecture.","title":"Metarepos"},{"location":"metarepos/metarepos/#what-is-a-metarepo","text":"A metarepo is a repository that contains links to other related repositories and usually serves as consolidating repository for a particular system, project or organisation i.e. system-level dependencies, build, deployment and release scripts are stored here. A nice article discussing metarepos can be found here","title":"What is a Metarepo?"},{"location":"metarepos/metarepos/#monorepos","text":"A dichotomy exists in the way we store and manage code at present, at one end of the spectrum we have the monorepo, a single repository containing all source code within a project or organisation. The monorepo has various advantages, for instance project discovery, dependencies and versioning are much simpler to manage. However, this comes at the expense of complicated, customised tooling, increasing complexity when scaling and upgrading the system and long CI/CD build times. Proponents of this methodology include companies like Google, Facebook and Twitter, many of whom can afford huge teams to customise tools to manage such an ecosystem.","title":"Monorepos"},{"location":"metarepos/metarepos/#multirepos","text":"At the other end of the spectrum, we have the multirepo architecture, where source code is split across many repositories. In this paradigm, the advantages and disadvantages of the monorepo are reversed i.e. the project is dissociated into smaller organised parts and these parts becomes easier to manage, whereas coordinating all of these fragmented pieces of software becomes a nightmare.","title":"Multirepos"},{"location":"metarepos/metarepos/#metarepos","text":"Metarepos provide a middle ground between these 2 polar extremes. Source code is stored across many repositories, allowing the organisation to capitalise on the benefits of a multirepo architecture. The fragmented code landscape is pieced together in a single repository or metarepo that stores links to the relevant code bases rather than the actual code itself. Actual code is pulled from the child repositories whenever required e.g. during build and delivery, enabling users to capitalise on the benefits of a monorepo architecture.","title":"Metarepos"},{"location":"user_guide/applying_commands/","text":"Applying Commands This section introduces how Gameta runs commands over multiple repositories. There are 3 parts to this section: Applying CLI Commands Parameterising CLI Commands Using Gameta Commands Applying Commands By default, Gameta applies CLI commands to all repositories (metarepo and all child repos). It also provides the flexibility to apply them to a user-defined selection of these repositories. There are 2 ways users can select repositories: Applying to Tagged Repositories Applying to Selected Repositories Applying to Tagged Repositories Tags provide a means to group and organise your child repositories and apply CLI commands selectively to these repositories. Supposing that one has the following .meta file: { projects : { gameta : { path : . , tags : [ metarepo ], url : git@github.com:genius-systems/gameta.git }, GitPython : { path : GitPython , tags : [ git ], url : https://github.com/gitpython-developers/GitPython.git }, gitdb : { path : core/gitdb , tags : [ git , core ], url : https://github.com/gitpython-developers/gitdb.git } } } If you only want to build the Python repositories tagged with git, you can run the following command: gameta apply -c python setup.py sdist bdist_wheel -t git Applying to Selected Repositories Users can apply a CLI command directly to a specified set of repositories, without needing to create tags. The same effect as described above can be achieved with the following command: gameta apply -c python setup.py sdist bdist_wheel -r GitPython -r gitdb Parameterising Commands CLI Commands can be customised for each repository by adding parameters (see Commands ). These parameters will be substituted for a particular repository whenever it is executed. Consider the following .meta file below containing the \"branch\" parameter that specifies the a branch: { projects : { gameta : { path : . , branch : develop , tags : [ metarepo ], url : git@github.com:genius-systems/gameta.git }, GitPython : { path : GitPython , branch : master , tags : [ git ], url : https://github.com/gitpython-developers/GitPython.git }, gitdb : { path : core/gitdb , branch : feature_a , tags : [ git , core ], url : https://github.com/gitpython-developers/gitdb.git } } } Supposing you would like to build a system with code checked out from those branches, you can run this command below: gameta apply -c git checkout {branch} -c python setup.py bdist_wheel This is the same as running the following bash commands: # To build gameta git checkout develop python setup.py bdist_wheel # To build GitPython cd GitPython git checkout master python setup.py bdist_wheel cd .. # To build gitdb cd core/gitdb git checkout feature_a python setup.py bdist_wheel cd ../.. Note To specify a parameter, enclose it in {curly_brackets}. The {branch} expression substitutes the branch parameter; multiple substitutions are supported. Using Gameta Commands Gameta commands are an abstraction of CLI commands applied with gameta apply , hence a Gameta command consists of all the parameters the gameta apply command i.e. CLI commands, tags, repositories, shell, verbose and raise errors. They simplify the gameta apply interface, allowing you to store commonly used commands and reuse them. To create a Gameta command, run the following: gameta cmd add -n hello -c git checkout {branch} -c python setup.py bdist_wheel This will add the command in the previous section to the Gameta command store under the name hello and run the following to invoke hello : gameta cmd exec -c hello Multiple Gameta commands can be executed: gameta cmd exec -c hello -c world","title":"Applying Commands"},{"location":"user_guide/applying_commands/#applying-commands","text":"This section introduces how Gameta runs commands over multiple repositories. There are 3 parts to this section: Applying CLI Commands Parameterising CLI Commands Using Gameta Commands","title":"Applying Commands"},{"location":"user_guide/applying_commands/#applying-commands_1","text":"By default, Gameta applies CLI commands to all repositories (metarepo and all child repos). It also provides the flexibility to apply them to a user-defined selection of these repositories. There are 2 ways users can select repositories: Applying to Tagged Repositories Applying to Selected Repositories","title":"Applying Commands"},{"location":"user_guide/applying_commands/#applying-to-tagged-repositories","text":"Tags provide a means to group and organise your child repositories and apply CLI commands selectively to these repositories. Supposing that one has the following .meta file: { projects : { gameta : { path : . , tags : [ metarepo ], url : git@github.com:genius-systems/gameta.git }, GitPython : { path : GitPython , tags : [ git ], url : https://github.com/gitpython-developers/GitPython.git }, gitdb : { path : core/gitdb , tags : [ git , core ], url : https://github.com/gitpython-developers/gitdb.git } } } If you only want to build the Python repositories tagged with git, you can run the following command: gameta apply -c python setup.py sdist bdist_wheel -t git","title":"Applying to Tagged Repositories"},{"location":"user_guide/applying_commands/#applying-to-selected-repositories","text":"Users can apply a CLI command directly to a specified set of repositories, without needing to create tags. The same effect as described above can be achieved with the following command: gameta apply -c python setup.py sdist bdist_wheel -r GitPython -r gitdb","title":"Applying to Selected Repositories"},{"location":"user_guide/applying_commands/#parameterising-commands","text":"CLI Commands can be customised for each repository by adding parameters (see Commands ). These parameters will be substituted for a particular repository whenever it is executed. Consider the following .meta file below containing the \"branch\" parameter that specifies the a branch: { projects : { gameta : { path : . , branch : develop , tags : [ metarepo ], url : git@github.com:genius-systems/gameta.git }, GitPython : { path : GitPython , branch : master , tags : [ git ], url : https://github.com/gitpython-developers/GitPython.git }, gitdb : { path : core/gitdb , branch : feature_a , tags : [ git , core ], url : https://github.com/gitpython-developers/gitdb.git } } } Supposing you would like to build a system with code checked out from those branches, you can run this command below: gameta apply -c git checkout {branch} -c python setup.py bdist_wheel This is the same as running the following bash commands: # To build gameta git checkout develop python setup.py bdist_wheel # To build GitPython cd GitPython git checkout master python setup.py bdist_wheel cd .. # To build gitdb cd core/gitdb git checkout feature_a python setup.py bdist_wheel cd ../.. Note To specify a parameter, enclose it in {curly_brackets}. The {branch} expression substitutes the branch parameter; multiple substitutions are supported.","title":"Parameterising Commands"},{"location":"user_guide/applying_commands/#using-gameta-commands","text":"Gameta commands are an abstraction of CLI commands applied with gameta apply , hence a Gameta command consists of all the parameters the gameta apply command i.e. CLI commands, tags, repositories, shell, verbose and raise errors. They simplify the gameta apply interface, allowing you to store commonly used commands and reuse them. To create a Gameta command, run the following: gameta cmd add -n hello -c git checkout {branch} -c python setup.py bdist_wheel This will add the command in the previous section to the Gameta command store under the name hello and run the following to invoke hello : gameta cmd exec -c hello Multiple Gameta commands can be executed: gameta cmd exec -c hello -c world","title":"Using Gameta Commands"},{"location":"user_guide/best_practices/","text":"Best Practices This section contains some tips and strategies to leverage Gameta's functionalities. Standardise your DevOps practices Standardising your DevOps practices for all your repositories will allow you to easily run tests, builds and other DevOps functionalities with gameta apply Group related repositories with tags Tag repositories to group related repositories e.g. Python, Backend, Frontend and apply commands to these. For example, if you have these repositories: backend_app_1 (written in Go) backend_app_2 (written in NodeJS) backend_app_3 (written in Go) frontend (written in NodeJS) You could use the following tags to help organise your repositories: Applications Tags backend_app_1 go, backend backend_app_2 nodejs, backend backend_app_3 go, backend frontend nodejs, frontend And the following commands to help manage your DevOps operations: gameta apply -c run_go_tests -t go gameta apply -c run_nodejs_tests -t nodejs gameta apply -c build_go_backend -t go gameta apply -c build_nodejs_backend -r backend_app_3","title":"Best Practices"},{"location":"user_guide/best_practices/#best-practices","text":"This section contains some tips and strategies to leverage Gameta's functionalities.","title":"Best Practices"},{"location":"user_guide/best_practices/#standardise-your-devops-practices","text":"Standardising your DevOps practices for all your repositories will allow you to easily run tests, builds and other DevOps functionalities with gameta apply","title":"Standardise your DevOps practices"},{"location":"user_guide/best_practices/#group-related-repositories-with-tags","text":"Tag repositories to group related repositories e.g. Python, Backend, Frontend and apply commands to these. For example, if you have these repositories: backend_app_1 (written in Go) backend_app_2 (written in NodeJS) backend_app_3 (written in Go) frontend (written in NodeJS) You could use the following tags to help organise your repositories: Applications Tags backend_app_1 go, backend backend_app_2 nodejs, backend backend_app_3 go, backend frontend nodejs, frontend And the following commands to help manage your DevOps operations: gameta apply -c run_go_tests -t go gameta apply -c run_nodejs_tests -t nodejs gameta apply -c build_go_backend -t go gameta apply -c build_nodejs_backend -r backend_app_3","title":"Group related repositories with tags"},{"location":"user_guide/commands/","text":"Command Reference Like git the gameta command delegates to subcommand groups based on its first argument. There are several subcommand groups: gameta init gameta sync gameta repo gameta tags gameta params gameta apply gameta cmd Note Bolded flags/arguments indicate that they are required, while italicised arguments indicate that they accept multiple arguments gameta init Initialises the folder as a metarepo, searches for a .git folder and attempts to populate the project name and Git URL from the .git folder. Arguments --git / -g: Indicates that Gameta should initialise this folder as a git repository --overwrite / -o: Indicates that Gameta should overwrite the existing .meta file with new data gameta sync Syncs all child repositories specified in the .meta file locally. gameta repo Repository subcommand group, contains the following commands: gameta repo add gameta repo delete gameta repo update gameta repo ls gameta repo add Adds a new child repository to the .meta file and clone it. If the repository is already cloned to the path provided, then extract its details and match them against the arguments that user provides. Arguments --name / -n : Name of the child repository to be stored --url / -u : URL of the child repository to be stored --path / -p : Relative local path within the project directory to clone the child repository to --overwrite / -o: Indicates that Gameta should overwrite the repository details in the .meta file if they exist gameta repo delete Deletes an existing child repository from the .meta file and its local clone. Arguments --name / -n : Name of the child repository to be deleted --no-clear / -c: Indicates that Gameta should not clear the local clone of the repository gameta repo update Updates repository details and syncs the changes locally Arguments --name / -n : Name of the child repository to be updated --new-name / -e: New repository name to be updated to --new-url / -u: New repository URL to be updated to --new-path / -p: New local relative path within the project directory to update to --no-sync / -s: Does not apply updates locally gameta repo ls Lists all repositories added gameta tags Tags subcommand group, contains the following commands: gameta tags add gameta tags delete gameta tags add Adds/updates tags of a particular repository. Arguments --name / -n : Name of the child repository to add tags to --tags / -t : Tags to be added to the child repository gameta tags delete Deletes selected tags from a particular repository. Arguments --name / -n : Name of the child repository to delete tags from --tags / -t : Tags to be deleted from the child repository gameta params Parameters subcommand group, contains the following commands: gameta params add gameta params delete gameta params add Adds a new set of parameters to all repositories, this can be done in 2 ways: User-prompt for each repository (default) Providing a default value that will be applied to all repositories Note If users choose a dict/list parameter types, then they need to input their parameter values as JSON decodable strings e.g. '{\"hello\": \"world\"}' or '[\"hello\", \"world\"]' Arguments --param / -p : Name of the parameter to be added to each repository --type / -t: Parameter type to be added for each repository, users can only choose one of the following: int, float, str (default), bool, dict, list --value / -v: Default value to be added for each repository in the event users input an invalid command when prompted or skip prompt entirely. Defaults to None --skip-prompt / -y: Skips user prompt and adds the default value to all parameter fields gameta params delete Deletes a parameter set from all repositories. Arguments --param / -p : Name of the parameter to be deleted gameta apply Applies a set of CLI commands to a specified set of repositories (see Applying Commands ) Arguments --command / -c : CLI commands to be applied --tags / -t : Tagged repositories to apply CLI commands to --repositories / -r : Names of specific repositories to apply CLI commands to --shell / -s: Indicates that the CLI commands should be executed in a separate shell --verbose / -v: Indicates that Gameta should display the CLI output when it executes a CLI command in other repositories --raise-errors / -e: Indicates that Gameta should terminate and raise errors that occur when executing CLI commands in child repositories Note The shell flag is required if the CLI command to be rendered is a piped CLI command, it will also be automatically added if multiple CLI commands are provided gameta cmd Command subcommand group, contains the following commands: gameta cmd add gameta cmd delete gameta cmd update gameta cmd ls gameta cmd exec gameta cmd add Adds a Gameta command to the Gameta command store within the .meta file Note A Gameta command is a gameta apply command consisting of a set of CLI commands, tags, repositories and flags (shell, verbose, raise errors) that control its execution Arguments --name / -n : Name --overwrite / -o: Indicates that Gameta should overwrite the existing .meta file with new data --command / -c : CLI commands to be applied --tags / -t : Tagged repositories to apply CLI commands to --repositories / -r : Names of specific repositories to apply CLI commands to --shell / -s: Indicates that the CLI command should be executed in a separate shell --verbose / -v: Indicates that Gameta should display the CLI output when it executes a CLI command in other repositories --raise-errors / -e: Indicates that Gameta should terminate and raise errors that occur when executing CLI commands in child repositories gameta cmd delete Deletes a Gameta command from the Gameta command store Arguments --name / -n : Name of the Gameta command to be deleted gameta cmd update Updates a Gameta command that exists in the Gameta command store Arguments --name / -n : Gameta command name to be updated --command / -c : New CLI commands to be executed --tags / -t : New repository tags apply CLI commands to --repositories / -r : New repositories to apply CLI commands to --verbose / -v: Display execution output when CLI commands are applied --no-verbose / -nv: Do not display execution output when CLI commands are applied --shell / -s: Execute CLI commands in a separate shell --no-verbose / -nv: Do not execute CLI commands in a separate shell --raise-errors / -e: Raise errors that occur when CLI commands are executed and terminate --no-errors / -ne: Do not raise errors that occur when CLI commands are executed and terminate gameta cmd ls Lists all existing Gameta commands in the Gameta command store gameta cmd exec Executes a series of Gameta command from the command store Arguments --commands / -c : Gameta commands to be executed","title":"Command Reference"},{"location":"user_guide/commands/#command-reference","text":"Like git the gameta command delegates to subcommand groups based on its first argument. There are several subcommand groups: gameta init gameta sync gameta repo gameta tags gameta params gameta apply gameta cmd Note Bolded flags/arguments indicate that they are required, while italicised arguments indicate that they accept multiple arguments","title":"Command Reference"},{"location":"user_guide/commands/#gameta-init","text":"Initialises the folder as a metarepo, searches for a .git folder and attempts to populate the project name and Git URL from the .git folder.","title":"gameta init"},{"location":"user_guide/commands/#arguments","text":"--git / -g: Indicates that Gameta should initialise this folder as a git repository --overwrite / -o: Indicates that Gameta should overwrite the existing .meta file with new data","title":"Arguments"},{"location":"user_guide/commands/#gameta-sync","text":"Syncs all child repositories specified in the .meta file locally.","title":"gameta sync"},{"location":"user_guide/commands/#gameta-repo","text":"Repository subcommand group, contains the following commands: gameta repo add gameta repo delete gameta repo update gameta repo ls","title":"gameta repo"},{"location":"user_guide/commands/#gameta-repo-add","text":"Adds a new child repository to the .meta file and clone it. If the repository is already cloned to the path provided, then extract its details and match them against the arguments that user provides.","title":"gameta repo add"},{"location":"user_guide/commands/#arguments_1","text":"--name / -n : Name of the child repository to be stored --url / -u : URL of the child repository to be stored --path / -p : Relative local path within the project directory to clone the child repository to --overwrite / -o: Indicates that Gameta should overwrite the repository details in the .meta file if they exist","title":"Arguments"},{"location":"user_guide/commands/#gameta-repo-delete","text":"Deletes an existing child repository from the .meta file and its local clone.","title":"gameta repo delete"},{"location":"user_guide/commands/#arguments_2","text":"--name / -n : Name of the child repository to be deleted --no-clear / -c: Indicates that Gameta should not clear the local clone of the repository","title":"Arguments"},{"location":"user_guide/commands/#gameta-repo-update","text":"Updates repository details and syncs the changes locally","title":"gameta repo update"},{"location":"user_guide/commands/#arguments_3","text":"--name / -n : Name of the child repository to be updated --new-name / -e: New repository name to be updated to --new-url / -u: New repository URL to be updated to --new-path / -p: New local relative path within the project directory to update to --no-sync / -s: Does not apply updates locally","title":"Arguments"},{"location":"user_guide/commands/#gameta-repo-ls","text":"Lists all repositories added","title":"gameta repo ls"},{"location":"user_guide/commands/#gameta-tags","text":"Tags subcommand group, contains the following commands: gameta tags add gameta tags delete","title":"gameta tags"},{"location":"user_guide/commands/#gameta-tags-add","text":"Adds/updates tags of a particular repository.","title":"gameta tags add"},{"location":"user_guide/commands/#arguments_4","text":"--name / -n : Name of the child repository to add tags to --tags / -t : Tags to be added to the child repository","title":"Arguments"},{"location":"user_guide/commands/#gameta-tags-delete","text":"Deletes selected tags from a particular repository.","title":"gameta tags delete"},{"location":"user_guide/commands/#arguments_5","text":"--name / -n : Name of the child repository to delete tags from --tags / -t : Tags to be deleted from the child repository","title":"Arguments"},{"location":"user_guide/commands/#gameta-params","text":"Parameters subcommand group, contains the following commands: gameta params add gameta params delete","title":"gameta params"},{"location":"user_guide/commands/#gameta-params-add","text":"Adds a new set of parameters to all repositories, this can be done in 2 ways: User-prompt for each repository (default) Providing a default value that will be applied to all repositories Note If users choose a dict/list parameter types, then they need to input their parameter values as JSON decodable strings e.g. '{\"hello\": \"world\"}' or '[\"hello\", \"world\"]'","title":"gameta params add"},{"location":"user_guide/commands/#arguments_6","text":"--param / -p : Name of the parameter to be added to each repository --type / -t: Parameter type to be added for each repository, users can only choose one of the following: int, float, str (default), bool, dict, list --value / -v: Default value to be added for each repository in the event users input an invalid command when prompted or skip prompt entirely. Defaults to None --skip-prompt / -y: Skips user prompt and adds the default value to all parameter fields","title":"Arguments"},{"location":"user_guide/commands/#gameta-params-delete","text":"Deletes a parameter set from all repositories.","title":"gameta params delete"},{"location":"user_guide/commands/#arguments_7","text":"--param / -p : Name of the parameter to be deleted","title":"Arguments"},{"location":"user_guide/commands/#gameta-apply","text":"Applies a set of CLI commands to a specified set of repositories (see Applying Commands )","title":"gameta apply"},{"location":"user_guide/commands/#arguments_8","text":"--command / -c : CLI commands to be applied --tags / -t : Tagged repositories to apply CLI commands to --repositories / -r : Names of specific repositories to apply CLI commands to --shell / -s: Indicates that the CLI commands should be executed in a separate shell --verbose / -v: Indicates that Gameta should display the CLI output when it executes a CLI command in other repositories --raise-errors / -e: Indicates that Gameta should terminate and raise errors that occur when executing CLI commands in child repositories Note The shell flag is required if the CLI command to be rendered is a piped CLI command, it will also be automatically added if multiple CLI commands are provided","title":"Arguments"},{"location":"user_guide/commands/#gameta-cmd","text":"Command subcommand group, contains the following commands: gameta cmd add gameta cmd delete gameta cmd update gameta cmd ls gameta cmd exec","title":"gameta cmd"},{"location":"user_guide/commands/#gameta-cmd-add","text":"Adds a Gameta command to the Gameta command store within the .meta file Note A Gameta command is a gameta apply command consisting of a set of CLI commands, tags, repositories and flags (shell, verbose, raise errors) that control its execution","title":"gameta cmd add"},{"location":"user_guide/commands/#arguments_9","text":"--name / -n : Name --overwrite / -o: Indicates that Gameta should overwrite the existing .meta file with new data --command / -c : CLI commands to be applied --tags / -t : Tagged repositories to apply CLI commands to --repositories / -r : Names of specific repositories to apply CLI commands to --shell / -s: Indicates that the CLI command should be executed in a separate shell --verbose / -v: Indicates that Gameta should display the CLI output when it executes a CLI command in other repositories --raise-errors / -e: Indicates that Gameta should terminate and raise errors that occur when executing CLI commands in child repositories","title":"Arguments"},{"location":"user_guide/commands/#gameta-cmd-delete","text":"Deletes a Gameta command from the Gameta command store","title":"gameta cmd delete"},{"location":"user_guide/commands/#arguments_10","text":"--name / -n : Name of the Gameta command to be deleted","title":"Arguments"},{"location":"user_guide/commands/#gameta-cmd-update","text":"Updates a Gameta command that exists in the Gameta command store","title":"gameta cmd update"},{"location":"user_guide/commands/#arguments_11","text":"--name / -n : Gameta command name to be updated --command / -c : New CLI commands to be executed --tags / -t : New repository tags apply CLI commands to --repositories / -r : New repositories to apply CLI commands to --verbose / -v: Display execution output when CLI commands are applied --no-verbose / -nv: Do not display execution output when CLI commands are applied --shell / -s: Execute CLI commands in a separate shell --no-verbose / -nv: Do not execute CLI commands in a separate shell --raise-errors / -e: Raise errors that occur when CLI commands are executed and terminate --no-errors / -ne: Do not raise errors that occur when CLI commands are executed and terminate","title":"Arguments"},{"location":"user_guide/commands/#gameta-cmd-ls","text":"Lists all existing Gameta commands in the Gameta command store","title":"gameta cmd ls"},{"location":"user_guide/commands/#gameta-cmd-exec","text":"Executes a series of Gameta command from the command store","title":"gameta cmd exec"},{"location":"user_guide/commands/#arguments_12","text":"--commands / -c : Gameta commands to be executed","title":"Arguments"}]}